---
layout: post
title: 📘【EffectiveC++】Chapter1-让自己习惯C++
date: 2025-8-2
---
## 视C++  为一个语言联邦

C++并不是某种特定语言，应该把它视为以下四种part of C语言的集合：
- C
- Object-Oriented C++
- Template C++
- STL

C++ 的高效编程指南会视情况而变化，取决于你使用了以上四个的哪一部分。

## 尽量以const，enum，inline替换#define
`#define`被作用于预处理阶段，它可能**从未被编译器看到**。所以自然就不会进入记号表内。这会导致当你定义了以下一个宏：
`#define ACCD_BG 1.62` 时，如果发生了某些编译错误，你只会在编译信息里看到 `1.62` 而不是 `ACCD_BG`


`#define` 无法提供封装性，因为它并**不重视作用域**。
一旦宏被定义，它就在其后的编译过程中有效，除非在某处被#undef


### 其他
- string对象通常比char* 更合适。
- C++一般总是要求你对使用的任何东西提供一个定义式。


## 尽可能使用const
### 如果你可以用const，请用


### const成员函数和mutable
const修饰成员函数的一大作用是保证这个函数不会修改类的非静态成员。
但是存在一个问题，即如果声明一个非const的指针来获取到了某个const修饰的成员地址。那你其实是可以通过这个指针来改变这片内存的。如果你用`const A a`, 且调用一个const修饰的成员函数，但你最终却还是通过一个指针p来改变了a的值。

即这种const成员函数的保证其实是不完全可靠的。

所以这里存在另外一种思维主张，即：即使是const修饰的成员函数，它也可以修改类成员的某些bit。你需要为这些可能被修改的成员前添加`mutable`修饰。


## 确保对象在使用前已经先被初始化
### 对内置对象总是手动初始化
C++并没有在所有语境保证会把你定义的对象进行默认初始化。int x； 有时候它会被初始化为0，有时候并不会。
所以最好的实践是：**永远在使用对象之前先把它初始化。**


### 使用初始化列表的方式而不是赋值
对于类的构造函数初始化，应该使用**初始化列表**的方式，而不是在构造函数中去给成员赋值。
	因为在构造函数中赋值的方法实际上是一种伪初始化，对象被实际调用default构造函数的时间比进入类的构造函数更早。
	对于内置对象（如int）则不一定，它不保证在构造函数之前一定被赋初值。
	所以如果使用在构造函数中赋值的方式， default构造函数所做的一切其实被浪费了。
	故初始化列表是一种更高效的方式。